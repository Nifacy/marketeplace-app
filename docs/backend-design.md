# Примерный дизайн кода backend части

## Предпосылки

Мы имеем ограничение - завязка конкретно под PostgresQL, так как нам необходимо использовать функционал специфичный для этой БД
(функции, процедуры, триггеры). Из-за того, что нам надо использовать эти фичи, некоторая бизнес логика просачиывается
на уровень базы данных.

По этой причине мы не можем использовать "стандарт" в виде добавления паттерна `Storage`. 

## Дизайн кода

Собственно, дизайн кода бэкенда следующий. Мы разбиваем всю логику приложения по трем слоям:

1. **Уровень схемы** - на этом уровне находятся все таблицы базы данных, схема, связанная с ними.
   Этот уровень должен быть как можно более устойчивым и подвергаться как можно меньшим изменениям.

2. **Уровень функций** - на этом уровне находятся все функции/процедуры/триггеры, хранящиеся в базе
   данных. На этом уровне мы добавляем бизнес логику, специфичную для нашего проекта, в базу данных,
   накладываем на изменение объектов базы данных какие-то ограничения. Функции/процедуры/триггеры
   реализуются на языке PLSQL. В идеале, каждый возможный usecase должен быть выражен в виде
   отдельной функции/процедуры/триггера (так мы добиваемся полного покрытия бизнес логики на этом
   уровне). Но, конечно, это лишь усложнит разработку, введением лищних функций. Поэтому добавление
   функций/процедур/триггеров делаем по надобности.

3. **Уровень кода** - здесь мы "оборачиваем" введенные на прошлом уровне функции/процедуры в компоненты
   языка программирования (функции, классы, структуры). Необходимость этого слоя обусловлена совместимостью
   с остальным кодом бэкенд части и упрощении взаимодействия с *уровнем функций*.

## Пример

Ниже показан пример частного случая того, как может быть реализовано добавление и получение пользователя

```python
class UserInfo(pydantic.Schema):
  name: str
  username: str
  age: int

class User:
  id: int
  info: UserInfo

def init_db() -> DatabaseConnection:
  '''Инициализация базы данных. Возвращает объект подключения к бд'''
  ...

def create_user(conn: DatabaseConnection, user: UserInfo) -> None:
  '''
  Вызывает функцию/процедуру, хранимую в бд.
  Здесь мы сериализуем и десериализуем данные в пригодный для
  передачи в базу данных
  '''
  ...

def get_user(conn: DatabaseConnection, user_id: int) -> User:
  ...

# api layer

app = FastAPI()
conn = init_db()

@app.post('/user/')
async def create_user_endpoint(user_info: UserInfo) -> None:
  try:
    create_user(conn, user_info)
  except:
    # возвращаем status code, соответствующий ошибке
    ...

@app.get('/user/')
async def get_user_endpoint(user_id: int) -> User:
  try:
    return get_user(conn, user_id)
  except:
    # возвращаем status code, соответствующий ошибке
    ...
```
